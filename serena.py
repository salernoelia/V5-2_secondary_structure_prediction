# -*- coding: utf-8 -*-
"""structure_prediction.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XJxWMak6hAljLgtaydectVAKZ1YuMC4q
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ---------------------------------------------------------
# PART 1: Data Loading
# ---------------------------------------------------------
# We use the hardcoded data from the file content you provided
# to ensure the script runs immediately without file dependency.
sequence = "NNCCNNHCNCNNCNNHNCHCCCHHNHHNNHHHNCHNNNHNHNNHCNNHHNCHHCCCCNNHHCNNCNNNNNNHNCNNHNNHNHNNNHNNNHHHCHHNHHCNNHNCHCCCNCNNCCCHNCNNCNNNHHHNHNCNHNHNNNHNCNNNNCNHHHCNNNNNNNNNHHNHHNNNNNHNCHNCCHNCCNHNCNHNHHHNNNHHNNHNNNHNCNHCCNCCNCHCNHHHHHHNHHHNNHNNNHHNHCCNCCCHHHCNNCCCCNCCHNNNCNNCHNHCHCNNNHHNNHNNNNHHHNNNNHNNCNNNNNNCCCHNNHNHNHCNNCNHNHHHNNNNHHNNHNNNNNHHNCNCCNNCCHCCNNNNHNNHCNNCCNNCNHCCHNNCHNHHNNHNHNNHHHHNCNNCCNNCHNNNNNNNNHHHHHHHHNCNNNCHCNHNNNNCNCNNHCCNCHCNNNC"
true_states_str = "00000000000000000000001111111111111111111110000000000000000000000000000000111111111111111111111000000000000000000000000001111111111111111111110000000000001111111111111111111110000000011111111111111111111100000000000011111111111111111111100000000000000000000000000000000011111111111111111111111111111111111111111100001111111111111111111110000000000000000000000000000000001111111111111111111110000011111111111111111111100000000000000000000000000"

print(f"Sequence Length: {len(sequence)}")

# Mappings
obs_map = {'C': 0, 'N': 1, 'H': 2}
state_map = {'0': 0, '1': 1} # 0: Outside, 1: Transmembrane
inv_state_map = {0: 'Outside', 1: 'TM'}

Y = [obs_map[c] for c in sequence]
X_true = [state_map[c] for c in true_states_str]

# ---------------------------------------------------------
# PART 2: Task 1 - Parameter Estimation
# ---------------------------------------------------------
print("\n--- Task 1: Parameter Estimation ---")

n_states = 2
n_obs = 3
trans_counts = np.zeros((n_states, n_states))
emit_counts = np.zeros((n_states, n_obs))

# Count Transitions
for t in range(len(X_true) - 1):
    trans_counts[X_true[t], X_true[t+1]] += 1

# Count Emissions
for t in range(len(X_true)):
    emit_counts[X_true[t], Y[t]] += 1

# Normalize to probabilities
A = trans_counts / trans_counts.sum(axis=1, keepdims=True)
B = emit_counts / emit_counts.sum(axis=1, keepdims=True)
Pi = np.array([1.0, 0.0]) # Assume start at state 0

print("Transition Matrix (A):")
print(pd.DataFrame(A, index=["From 0", "From 1"], columns=["To 0", "To 1"]))
print("\nEmission Matrix (B):")
print(pd.DataFrame(B, index=["State 0 (Out)", "State 1 (TM)"], columns=["C", "N", "H"]))

# ---------------------------------------------------------
# PART 3: Task 2 - Viterbi Algorithm & Accuracy
# ---------------------------------------------------------
print("\n--- Task 2: Viterbi Prediction ---")

def viterbi(obs, A, B, Pi):
    T = len(obs)
    N = A.shape[0]
    delta = np.zeros((T, N))
    psi = np.zeros((T, N), dtype=int)

    with np.errstate(divide='ignore'):
        log_A = np.log(A + 1e-10)
        log_B = np.log(B + 1e-10)
        log_Pi = np.log(Pi + 1e-10)

    delta[0] = log_Pi + log_B[:, obs[0]]

    for t in range(1, T):
        for j in range(N):
            probs = delta[t-1] + log_A[:, j]
            psi[t, j] = np.argmax(probs)
            delta[t, j] = np.max(probs) + log_B[j, obs[t]]

    path = np.zeros(T, dtype=int)
    path[T-1] = np.argmax(delta[T-1])

    for t in range(T-2, -1, -1):
        path[t] = psi[t+1, path[t+1]]
    return path

predicted_states = viterbi(Y, A, B, Pi)

# Calculate Accuracy
correct = sum(1 for p, t in zip(predicted_states, X_true) if p == t)
accuracy = correct / len(X_true)
print(f"Prediction Accuracy: {accuracy:.4f} ({correct}/{len(X_true)})")

# ---------------------------------------------------------
# PART 4: Task 3 - Conditional Probabilities P(Y_t+1 | Y_t)
# ---------------------------------------------------------
print("\n--- Task 3: Conditional Probabilities ---")

# Calculate Stationary Distribution
eigenvals, eigenvecs = np.linalg.eig(A.T)
stationary = np.real(eigenvecs[:, np.isclose(eigenvals, 1)])
stationary = stationary / stationary.sum()
stationary = stationary.flatten()

cond_prob_obs = np.zeros((n_obs, n_obs))
p_obs = np.zeros(n_obs)

# P(O) = Sum_s P(O|s)P(s)
for o in range(n_obs):
    p_obs[o] = np.sum(B[:, o] * stationary)

# P(O_next | O_curr)
for o1 in range(n_obs):
    for o2 in range(n_obs):
        joint_prob = 0
        for s1 in range(n_states):
            for s2 in range(n_states):
                # P(O2|s2) * P(s2|s1) * P(O1|s1) * P(s1)
                term = B[s2, o2] * A[s1, s2] * B[s1, o1] * stationary[s1]
                joint_prob += term
        cond_prob_obs[o1, o2] = joint_prob / p_obs[o1]

print("Conditional Probability Matrix P(Obs_next | Obs_current):")
print(pd.DataFrame(cond_prob_obs,
      index=[f"Given {c}" for c in ['C', 'N', 'H']],
      columns=[f"Next {c}" for c in ['C', 'N', 'H']]))

# ---------------------------------------------------------
# PART 5: Task 4 - Radical Change (Sensitivity)
# ---------------------------------------------------------
print("\n--- Task 4: Radical Change Analysis ---")
B_ambiguous = np.array([[0.33, 0.33, 0.33], [0.33, 0.33, 0.33]])
B_deterministic = np.array([[0.5, 0.5, 0.0], [0.0, 0.0, 1.0]])

acc_amb = sum(1 for p, t in zip(viterbi(Y, A, B_ambiguous, Pi), X_true) if p == t) / len(X_true)
acc_det = sum(1 for p, t in zip(viterbi(Y, A, B_deterministic, Pi), X_true) if p == t) / len(X_true)

print(f"Accuracy with Ambiguous Emissions (Uniform): {acc_amb:.4f}")
print(f"Accuracy with Deterministic Emissions (Strict Separation): {acc_det:.4f}")

# ---------------------------------------------------------
# PART 6: Visualization (The Graphic for Presentation)
# ---------------------------------------------------------
plt.figure(figsize=(14, 4))

# Plot True States
plt.step(range(len(X_true)), X_true, where='mid', label='True Annotation', color='blue', linewidth=2, alpha=0.6)

# Plot Predicted States (dashed, slightly offset for visibility)
offset_pred = [x + 0.05 for x in predicted_states]
plt.step(range(len(predicted_states)), offset_pred, where='mid', label='HMM Prediction', color='red', linestyle='--', linewidth=2)

# Highlight Errors
errors = [i for i, (t, p) in enumerate(zip(X_true, predicted_states)) if t != p]
if errors:
    plt.scatter(errors, [0.5]*len(errors), color='black', marker='x', label='Mismatches', zorder=5)

plt.yticks([0, 1], ['Outside (0)', 'Transmembrane (1)'])
plt.xlabel('Sequence Position (Amino Acid Index)')
plt.ylabel('State')
plt.title(f'SecY Protein Structure: True vs Predicted (Accuracy: {accuracy:.2%})')
plt.legend(loc='center right')
plt.grid(True, axis='y', alpha=0.3)
plt.tight_layout()

print("\nGenerating plot window...")
plt.show()
